import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,o as a,b as n}from"./app-DjF3qBm_.js";const l="/web-docs/assets/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4-Dq0_8JAn.png",t="/web-docs/assets/%E7%BA%BF%E7%A8%8B-C8CRJ-Fk.png",h="/web-docs/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E7%A8%8B-BpRtBVB8.png",e="/web-docs/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-TpANtnxk.png",p="/web-docs/assets/%E6%B8%B2%E6%9F%93%E7%BA%BF%E7%A8%8B%E6%8E%92%E9%98%9F-B58IYR-z.png",k="/web-docs/assets/%E5%90%8C%E6%AD%A5-DzpY655q.png",d="/web-docs/assets/%E5%BC%82%E6%AD%A5-DEtoO-dP.png",r="/web-docs/assets/%E5%AE%9A%E6%97%B6%E5%99%A8%E9%98%9F%E5%88%97%E6%89%A7%E8%A1%8C-CVCaHy0t.png",g="/web-docs/assets/%E6%A1%88%E4%BE%8B%E4%BA%8C-Be2Msew0.png",o="/web-docs/assets/%E6%A1%88%E4%BE%8B%E4%B8%89-LhkyNMAc.png",B={},c=n('<h1 id="浏览器的事件循环机制" tabindex="-1"><a class="header-anchor" href="#浏览器的事件循环机制"><span>浏览器的事件循环机制</span></a></h1><h3 id="一、浏览器的进程模型" tabindex="-1"><a class="header-anchor" href="#一、浏览器的进程模型"><span>一、浏览器的进程模型</span></a></h3><h4 id="_1-何为进程" tabindex="-1"><a class="header-anchor" href="#_1-何为进程"><span>1. 何为进程</span></a></h4><p><strong>程序运行需要有它自己专属的内存空间，可以把这块内存空间简单的理解为进程。</strong></p><p><img src="'+l+'" alt="内存空间"></p><p><strong>每个应用至少有一个进程，进程之间相互独立，即使要通信，也需要双方同意。</strong></p><p>以上图例中的三个程序：QQ、微信、王者荣耀，他们内存都是相互独立的。有的多有的少，但是这无所谓。</p><p>主要能看到的是它们的内存相互之间是没有交叉的。因为如果交叉了，就会变成共享共用了，这会出现大问题的。</p><p>因为进程之所以这样设计，它的目的就是为了隔离。</p><p>隔离的好处是什么呢？比如说：QQ程序出现了问题，崩溃了，不会影响到微信和王者荣耀的运行。</p><p>进程之间是相互隔离的，那么它们之间能不能互相通信呢？比方说：QQ里面想用微信里面的东西。不是说完全不行，只要QQ想要，微信愿意给就行。也就是说即使要通信，也要双方同意才行。</p><h4 id="_2-何为线程" tabindex="-1"><a class="header-anchor" href="#_2-何为线程"><span>2. 何为线程</span></a></h4><p>有了进程后，就有了内存空间。就可以运行程序的代码了。</p><p><strong>运行代码的【人】称之为【线程】。</strong></p><p><strong>一个进程至少有一个线程，所以在进程开启后会自动创建一个线程来运行代码，该线程称之为主线程。</strong>（如果主线程结束了，整个程序也就结束了）</p><p>如果程序需要同时执行多块代码，主线程就会启动更多的线程来执行代码，所以一个进程中可以包含多个线程。</p><p><img src="'+t+'" alt="线程"></p><p>比方说我们以上图的王者荣耀为例：</p><p>王者荣耀是一个程序，它是一个进程。它启动之后就会为它分配一块内存空间，空间有了就需要开始干活了。</p><p>它启动的时候会产生一个主线程，主线程有很多的任务需要一个个去做。同时还有游戏线程和网络线程来处理对应线程的任务。</p><p>它要同时进行很多的事情，那么就会产生很多的线程。这里只是举例说明。</p><p>那么这些任务要用到的内存空间在哪呢？就是启动王者荣耀时分配的内存空间，这些线程都是共享的同一块内存空间。</p><h4 id="_3-浏览器有哪些进程和线程" tabindex="-1"><a class="header-anchor" href="#_3-浏览器有哪些进程和线程"><span>3. 浏览器有哪些进程和线程</span></a></h4><p><strong>浏览器是一个多进程多线程的应用程序。</strong></p><p>浏览器内部工作极其复杂。</p><p>为了避免相互影响，为了减少连环崩溃的几率，当启动浏览器后，它会自动启动多个进程。</p><p><img src="'+h+'" alt="浏览器进程"></p><blockquote><p>可以在浏览器的任务管理器中查看当前的所有进程。</p></blockquote><p><img src="'+e+'" alt="浏览器任务管理工具"></p><p>其中，最主要的进程有：</p><ol><li><p>浏览器进程</p><p>主要负责页面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务。</p></li><li><p>网络进程</p><p>负责加载网络资源，网络进程内部会启动多个线程来处理不同的网络任务。</p></li><li><p><strong>渲染进程（主要掌握的进程）</strong></p><p><strong>渲染进程启动后，会开启一个渲染主线程，主线程负责执行 HTML、CSS、JS 代码。</strong></p><p>默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不互相影响。</p><blockquote><p>将来该默认模式可能会有所改变，有兴趣了解可以参见 chrome 官方说明文档</p></blockquote></li></ol><h3 id="二、渲染主线程是如何工作的" tabindex="-1"><a class="header-anchor" href="#二、渲染主线程是如何工作的"><span>二、渲染主线程是如何工作的？</span></a></h3><p>渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于：</p><ul><li>解析 HTML</li><li>解析 CSS</li><li>计算样式</li><li>布局</li><li>处理图层</li><li>每秒把页面画 60 次</li><li>执行全局 JS 代码</li><li>执行事件处理函数</li><li>执行计时器的回调函数</li><li>····</li></ul><blockquote><p>思考题：为什么渲染进程不适用多个线程来处理这些事情？</p></blockquote><p>要处理这么多的任务，主线程遇到了一个前所未有的难题：如何调度任务？</p><p>比如：</p><ul><li>我正在执行一个 JS 函数，执行到一半的时候用户点击了按钮，我该立即去执行点击事件的处理函数吗？</li><li>我正在执行一个 JS 函数，执行到一半的时候某个计时器到达了时间，我该立即去执行它的回调吗？</li><li>浏览器进程通知我 “用户点击了按钮”，与此同时，某个计时器也到达了时间，我该处理哪一个呢？</li><li>·····</li></ul><p>渲染主线程想出一个绝妙的主意来处理这个问题：排队。</p><p><img src="'+p+'" alt="渲染线程排队"></p><p><strong>在上图中（很重要）：</strong></p><ol><li><strong>在最开始的时候，渲染主线程会进入一个无限循环。</strong></li><li><strong>每一次循环会检查消息队列中是否有任务存在。如果有，就取出第一个任务执行，执行完一个后进入下一次循环；如果没有，则进入休眠状态。</strong></li><li><strong>其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务。</strong></li></ol><p>这样一来，就可以让每个任务有条不紊的、持续的进行下去了。</p><p><strong>整个过程，被称之为事件循环（或者消息循环）。</strong></p><p>注意：主线程中正在执行的任务也有可能会产生一个新的任务，并添加到任务队列中等待主线程执行。</p><h3 id="三、若干解释" tabindex="-1"><a class="header-anchor" href="#三、若干解释"><span>三、若干解释</span></a></h3><h4 id="_1-何为异步" tabindex="-1"><a class="header-anchor" href="#_1-何为异步"><span>1. 何为异步</span></a></h4><p>代码在执行过程中，会遇到一些无法立即处理的任务，比如：</p><ul><li>计时器到达时间后需要执行的任务 -- <code>setTimeout</code>、<code>setInterval</code></li><li>网络通信完成后需要执行的任务 -- <code>XHR</code>、<code>Fetch</code></li><li>用户操作后需要执行的任务 -- <code>addEventListener</code></li></ul><p>如果让渲染主线程等待这些任务的时机达到，就会导致主线程长期处于 【堵塞】 的状态，从而导致浏览器 【卡死】。</p><p><img src="'+k+'" alt="同步"></p><p>上图就是通知 计时线程 进行计时器（<code>setTimeout</code>、<code>setInterval</code>)的 <strong>同步流程</strong>。</p><p>可以发现：</p><ul><li><p>在第 ① 步时，计时线程开始计时。</p></li><li><p>在第 ② 步时，渲染主线程等待该计时器的计时完成。</p></li><li><p>在第 ③ 步时，计时器计时结束后，渲染主线程执行计时器的回调函数。</p></li></ul><p>不难看出，在同步的流程中，如果渲染主线程等待计时器的完成，需要阻塞一段时间，导致主线程本应要执行的任务无法执行。</p><p>如果此时有多个计时器，那么主线程就会等待很长的时间，导致卡死。</p><p><strong>渲染主线程承担着极其重要的工作，无论如何都不能阻塞！</strong></p><p>因此，浏览器选择 <strong>异步</strong> 来解决这个问题。</p><p><img src="'+d+`" alt="异步"></p><p>上图就是通知计时器线程进行计时的 <strong>异步流程</strong>。</p><p>可以发现：</p><ul><li><p>在第 ① 步时，计时线程开始计时。</p></li><li><p><strong>在第 ② 步时，对于主线程来说，计时器这个任务的操作已经结束了，渲染主线程不会等待该计时器的计时完成，而是继续执行后面的任务。</strong></p></li><li><p><strong>在第 ③ 步时，计时器计时结束后，计时器线程会把计时器结束后的回调函数添加到渲染主线程的任务队列中，等待渲染主线程进行执行。</strong></p></li></ul><p><strong>使用异步的方式，渲染主线程永不阻塞。</strong></p><blockquote><p>面试题：如何理解 JS 的异步？</p><p>参考答案：</p><p>JS 是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。渲染主线程承担着诸多的工作，渲染页面、执行 JS 都在其中运行。</p><p>如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。</p><p>所以，浏览器采用异步的方式来避免。</p><p>具体做法是当某些任务发生时，比如：计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。</p><p>在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。</p></blockquote><h4 id="_2-js-为什么会阻碍渲染" tabindex="-1"><a class="header-anchor" href="#_2-js-为什么会阻碍渲染"><span>2. JS 为什么会阻碍渲染？</span></a></h4><p>先看代码：</p><div class="language-html line-numbers-mode" data-highlighter="shiki" data-ext="html" data-title="html" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;!</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">DOCTYPE</span><span style="--shiki-light:#6F42C1;--shiki-dark:#D19A66;"> html</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">html</span><span style="--shiki-light:#6F42C1;--shiki-dark:#D19A66;"> lang</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;en&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">meta</span><span style="--shiki-light:#6F42C1;--shiki-dark:#D19A66;"> charset</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;UTF-8&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">meta</span><span style="--shiki-light:#6F42C1;--shiki-dark:#D19A66;"> http-equiv</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;X-UA-Compatible&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#D19A66;"> content</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;IE=edge&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">meta</span><span style="--shiki-light:#6F42C1;--shiki-dark:#D19A66;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;viewport&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#D19A66;"> content</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;width=device-width, initial-scale=1.0&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">title</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;Document&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">title</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;JavaScript is awesome!&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;change&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> h1</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> document</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">querySelector</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&#39;h1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> btn</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> document</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">querySelector</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&#39;button&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 死循环指定的时间</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> delay</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">duration</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">      const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> start</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> Date</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">      while</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">Date</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> start</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> duration</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    btn</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">onclick</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">      h1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">textContent</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &#39;老子很帅&#39;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">      delay</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">3000</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">html</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行以上代码，并在浏览器中操作后发现，点击按钮，3S 后，页面的 h1 元素内容发生了变化。</p><p>按照代码执行的顺序，为什么不是先改变文本，而是会等待 3S 后才改变文本呢？为什么会造成这样的结果呢？</p><p>我们用事件循环机制的流程进行讲解：</p><ol><li>首先渲染主线程开始执行上述代码的 JS，获取 h1、btn 元素、声明了一个函数、给按钮注册了一个点击事件。</li><li>渲染主线程在执行到 <code>btn.onclick</code> 注册点击事件时，做了什么事情呢？它会通知这个 <strong>交互线程</strong> 去监听这个按钮的点击事件。然后主线程就会结束 <code>btn.onclick</code> 这个任务，转而继续执行之后的任务。</li><li>当用户点击了按钮时，<strong>交互线程</strong> 就会监听都按钮点击事件，并把事件的回调函数包装成任务添加到消息队列中进行排队。</li><li>当主线程执行完点击事件之前的任务时，就会在消息队列中拿取该点击事件的回调函数并执行。</li><li>主线程执行该点击事件回调函数的过程中在干嘛？首先是把 h1 元素的文本进行修改设置，但是 <strong>注意：设置了并不代表在浏览器上能看得见，我要在浏览器上能看得见新的东西需要重新渲染，需要重新绘制。</strong></li><li>当文本修改后，会产生一个新的任务，就是一个 <strong>绘制任务</strong>。并把该绘制任务添加到任务队列中，等待主线程拿取执行。</li><li>然后点击事件的回调继续往下执行，调用了 <code>delay(3000)</code> 函数，死循环了 3S 的时间。导致绘制任务不能马上执行。</li><li>当 3S 死循环结束后，按钮的点击事件回调函数也就结束了。这个时候主线程也就完成了按钮的点击事件回调任务，然后就可以去执行 <strong>绘制任务</strong> 了。</li></ol><p>这就是为什么在执行上述代码时，会卡了 3S 的时间才看到最终结果。其实它的文本内容早就修改完成了，只是没有及时的渲染出来。</p><p>注意：如果在死循环的 3S 期间，用户点击了其他东西，做的其他操作全部都要添加到后面消息队列中排队，全部都需要等待当前这个点击事件执行完成后才能执行后面的任务。</p><h4 id="_3-任务有优先级吗" tabindex="-1"><a class="header-anchor" href="#_3-任务有优先级吗"><span>3. 任务有优先级吗</span></a></h4><p><strong>任务没有优先级，在消息队列中先进先出。</strong></p><p><strong>但是消息队列是有优先级的。</strong></p><p>根据 W3C 的 <strong>最新解释</strong>：</p><ul><li><strong>每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。</strong></li><li>同一个类型的任务必须在一个队列：意思是说一个任务可以有多个不同类型的队列，同一个类型（比如果说点击事件）可以在队列1、也可以在队列2，但是注意！！该类型的所有事件都必须在队列1或者队列2，而不是一部分在队列1、一部分在队列2。</li><li>不同类型的任务可以分属于不同的队列：意思是说，比如计时器的事件任务可以放在 非计时器队列中（比如网络队列中）。</li><li><strong>浏览器必须准备好一个微队列，微队列中的任务优先其他所有任务执行。</strong> https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint</li></ul><blockquote><p><strong>随着浏览器的复杂度急剧提升，W3C 不再使用宏队列的说法</strong></p></blockquote><p>在 <strong>之前的解释</strong>：</p><ul><li>任务有两个队列，一个是普通的宏任务队列，一个是优先的微任务队列。</li><li>抛弃之前的队列用法是因为两个队列根本搞不定现在的这么复杂的浏览器场景。</li></ul><p>在目前 chrome 的实现中，至少包含了下面的队列：</p><ul><li>延迟队列：用于存放计时器到达后的回调任务，优先级【中】</li><li>交互队列：用于存放用户操作后产生的事件处理任务，优先级【高】</li><li>微队列：用户存放需要最快执行的任务，优先级【最高】</li></ul><blockquote><p>添加任务到微队列的主要方式：主要是使用 Promise、MutationObserver</p><p>例如：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 立即把一个函数添加到微队列</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">函数</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><blockquote><p>浏览器还有很多其他的队列，由于和我们开发关系不大，不做考虑。</p></blockquote><p>假如有一下代码：</p><h5 id="_1-案例一" tabindex="-1"><a class="header-anchor" href="#_1-案例一"><span>（1）案例一</span></a></h5><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们执行以上代码时，发现运行后的结果是先输出2，再输出1。</p><p>为什么会这样呢？</p><ol><li>首先上述的代码是全局 JS 代码，所以 <strong>渲染主线程会先执行这块的 JS 代码</strong>。</li><li>执行的过程中遇到了 <code>setTimeout</code>，<strong>主线程就会通知和定时相关的线程</strong>，让该线程开始计时，并监听定时器的回调函数。</li><li>主线程结束该定时器 <code>setTimeout</code> 的任务，接着执行后面的 <code>console.log(2)</code> 代码。</li><li>当 0S 时间到达后，定时器相关线程就会把该定时器的回调添加到 <strong>延迟队列</strong>中。</li><li>当主线程执行完后面的 <code>console.log(2)</code> 代码后，发现没有其他任务了（<strong>一定是执行完所有任务后才回去其他队列中拿取任务继续执行</strong>）。就会先去微队列中查看是否有任务【优先级最高】，发现没有微任务。接着去交互队列中查看是否有任务【优先级高】，发现还是没有任务。最后去延迟队列中查看是否有任务【优先级中】，发现有一个定时器的回调函数，那么主线程就会拿取该任务进行执行，也就是执行 <code>console.log(1)</code>。</li><li>所以上述代码执行的结果是先输出 2，再输出 1。</li></ol><p>执行的队列如下图所示：</p><p><img src="`+r+`" alt="定时器队列执行"></p><h5 id="_2-案例二" tabindex="-1"><a class="header-anchor" href="#_2-案例二"><span>（2）案例二</span></a></h5><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 死循环指定的时间</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> delay</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">duration</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> start</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> Date</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">Date</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> start</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> duration</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">delay</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们执行以上代码时，结果是：等待 1S 后，先输出 2，再输出 1。</p><p>为什么会这样呢？</p><ol><li>首先上述的代码是全局 JS 代码，所以 <strong>渲染主线程会先执行这块的 JS 代码</strong>。</li><li>执行的过程中遇到了 <code>setTimeout</code>，<strong>主线程就会通知和定时相关的线程</strong>，让该线程开始计时，并监听定时器的回调函数。</li><li>主线程结束该定时器 <code>setTimeout</code> 的任务，接着执行后面的代码 <code>delay(1000)</code>，<code>delay(1000)</code> 的作用是死循环等待 1S 的时间。然后继续执行 <code>console.log(2)</code>。</li><li>当 0S 时间到达后，定时器相关线程就会把该定时器的回调添加到 <strong>延迟队列</strong>中。</li><li>当主线程执行完后面的 <code>console.log(2)</code> 代码后，发现没有其他任务了（<strong>一定是执行完所有任务后才回去其他队列中拿取任务继续执行</strong>）。就会先去微队列中查看是否有任务【优先级最高】，发现没有微任务。接着去交互队列中查看是否有任务【优先级高】，发现还是没有任务。最后去延迟队列中查看是否有任务【优先级中】，发现有一个定时器的回调函数，那么主线程就会拿取该任务进行执行，也就是执行 <code>console.log(1)</code>。</li><li>所以上述代码执行的结果是先输出 2，再输出 1。</li></ol><p>执行的队列如下图所示：</p><p><img src="`+g+`" alt="案例二"></p><h5 id="_3-案例三" tabindex="-1"><a class="header-anchor" href="#_3-案例三"><span>（3）案例三</span></a></h5><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们执行以上代码时，结果是：先输出 3，接着输出 2，最后输出1。</p><p>为什么会这样呢？</p><ol><li>首先上述的代码是全局 JS 代码，所以 <strong>渲染主线程会先执行这块的 JS 代码</strong>。</li><li>执行的过程中遇到了 <code>setTimeout</code>，<strong>主线程就会通知和定时相关的线程</strong>，让该线程开始计时，并监听定时器的回调函数。</li><li>主线程结束该定时器 <code>setTimeout</code> 的任务，接着执行后面的代码 <code>Promise.resolve().then()</code>，运到 <code>Promise</code>，<strong>主线程就会通知和异步相关的线程</strong>，让该线程把异步的回调包装成任务，<strong>添加到微队列中</strong>。</li><li>主线程结束该异步任务，接着执行后面的 <code>console.log(3)</code>。</li><li>当 0S 时间到达后，定时器相关线程就会把该定时器的回调添加到 <strong>延迟队列</strong> 中。</li><li>当主线程执行完后面的 <code>console.log(3)</code> 代码后，发现没有其他任务了（<strong>一定是执行完所有任务后才回去其他队列中拿取任务继续执行</strong>）。就会先去微队列中查看是否有任务【优先级最高】，发现有微任务的回调。执行 <code>console.log(2)</code>。接着去交互队列中查看是否有任务【优先级高】，发现没有任务。最后去延迟队列中查看是否有任务【优先级中】，发现有一个定时器的回调函数，那么主线程就会拿取该任务进行执行，也就是执行 <code>console.log(1)</code>。</li><li>所以上述代码执行的结果是先输出 3，接着输出 2，最后输出1。</li></ol><p>执行的队列如下图所示：</p><p><img src="`+o+`" alt="案例三"></p><h5 id="_4-案例四" tabindex="-1"><a class="header-anchor" href="#_4-案例四"><span>（4）案例四</span></a></h5><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> a</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">    Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">        console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">    Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们执行以上代码时，结果是：先输出 5，接着输出 4，接着输出3，接着输出 1，最后输出 2。</p><p>为什么会这样呢？</p><ol><li>首先上述的代码是全局 JS 代码，所以 <strong>渲染主线程会先执行这块的 JS 代码</strong>。</li><li>执行的过程中遇到了 <code>setTimeout</code>，<strong>主线程就会通知和定时相关的线程</strong>，让该线程开始计时，并监听定时器的回调函数。</li><li>主线程结束该定时器 <code>setTimeout</code> 的任务，接着执行后面的代码 <code>Promise.resolve().then()</code>，运到 <code>Promise</code>，<strong>主线程就会通知和异步相关的线程</strong>，让该线程把异步的回调包装成任务，<strong>添加到微队列中</strong>。</li><li>主线程结束该异步任务，接着执行后面的 <code>console.log(5)</code>。</li><li>当 0S 时间到达后，定时器相关线程就会把该定时器的回调添加到 <strong>延迟队列</strong> 中。</li><li>当主线程执行完后面的 <code>console.log(5)</code> 代码后，发现没有其他任务了（<strong>一定是执行完所有任务后才回去其他队列中拿取任务继续执行</strong>）。就会先去微队列中查看是否有任务【优先级最高】，发现有微任务的回调。执行 <code>console.log(4)</code>。接着去交互队列中查看是否有任务【优先级高】，发现没有任务。最后去延迟队列中查看是否有任务【优先级中】，发现有一个定时器的回调函数，那么主线程就会拿取该任务进行执行，也就是执行 <code>console.log(3)</code>，然后发现该任务的回调中还有一个 <code>Promise.resolve().then()</code>，<strong>主线程就会通知和异步相关的线程</strong>，让该线程把异步的回调包装成任务，<strong>添加到微队列中</strong>。</li><li>主线程结束该计时器的回调后，发现后面没有任务了，接着按照优先级的顺序去相关队列中查看是否有需要执行的任务。发现在微队列中有一个任务，那么就会执行该任务中的回调 <code>console.log(1)</code>，然后发现又有一个 <code>Promise.resolve().then()</code>，<strong>主线程就会通知和异步相关的线程</strong>，让该线程把异步的回调包装成任务，<strong>添加到微队列中</strong>。</li><li>主线程结束上一个微任务的回调任务，继续在队列中查看是否有任务需要执行，发现在未队列中有需要执行的任务。执行回调中的 <code>console.log(2)</code>。</li><li>所以上述代码执行的结果是先输出 5，接着输出 4，接着输出3，接着输出 1，最后输出 2。</li></ol><h3 id="四、面试题" tabindex="-1"><a class="header-anchor" href="#四、面试题"><span>四、面试题</span></a></h3><blockquote><p>面试题：阐述一下 JS 的事件循环</p><p>参考答案：</p><p>事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。</p><p>首先， JavaScript 是单线程工作的，所以在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环渲染主线程会从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。</p><p>过去把消息队列简单分为宏队列和微队列，这种说法目前已经无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。</p><p>根据 W3C 官方的解释，每一个任务有不同的类型，同类型的任务必须在同一个队列中，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。</p></blockquote><blockquote><p>面试题：JS 中的计时器能做到精确计时吗？为什么？</p><p>参考答案：</p><p>不行，因为：</p><ol><li>计算机硬件没有原子钟，无法做到精确计时。</li><li>操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调用的是操作系统的函数，也就携带了这些偏差。</li><li>按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 4 毫秒的最少时间，这样在计时时间少于 4 毫秒时又带来了偏差。</li><li>受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差。</li></ol></blockquote>`,115),E=[c];function y(A,F){return a(),i("div",null,E)}const C=s(B,[["render",y],["__file","index.html.vue"]]),m=JSON.parse('{"path":"/%E5%89%8D%E7%AB%AF/Browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/","title":"浏览器的事件循环机制","lang":"zh-CN","frontmatter":{},"headers":[{"level":3,"title":"一、浏览器的进程模型","slug":"一、浏览器的进程模型","link":"#一、浏览器的进程模型","children":[{"level":4,"title":"1. 何为进程","slug":"_1-何为进程","link":"#_1-何为进程","children":[]},{"level":4,"title":"2. 何为线程","slug":"_2-何为线程","link":"#_2-何为线程","children":[]},{"level":4,"title":"3. 浏览器有哪些进程和线程","slug":"_3-浏览器有哪些进程和线程","link":"#_3-浏览器有哪些进程和线程","children":[]}]},{"level":3,"title":"二、渲染主线程是如何工作的？","slug":"二、渲染主线程是如何工作的","link":"#二、渲染主线程是如何工作的","children":[]},{"level":3,"title":"三、若干解释","slug":"三、若干解释","link":"#三、若干解释","children":[{"level":4,"title":"1. 何为异步","slug":"_1-何为异步","link":"#_1-何为异步","children":[]},{"level":4,"title":"2. JS 为什么会阻碍渲染？","slug":"_2-js-为什么会阻碍渲染","link":"#_2-js-为什么会阻碍渲染","children":[]},{"level":4,"title":"3. 任务有优先级吗","slug":"_3-任务有优先级吗","link":"#_3-任务有优先级吗","children":[{"level":5,"title":"（1）案例一","slug":"_1-案例一","link":"#_1-案例一","children":[]},{"level":5,"title":"（2）案例二","slug":"_2-案例二","link":"#_2-案例二","children":[]},{"level":5,"title":"（3）案例三","slug":"_3-案例三","link":"#_3-案例三","children":[]},{"level":5,"title":"（4）案例四","slug":"_4-案例四","link":"#_4-案例四","children":[]}]}]},{"level":3,"title":"四、面试题","slug":"四、面试题","link":"#四、面试题","children":[]}],"git":{"createdTime":1720303462000,"updatedTime":1720303462000,"contributors":[{"name":"wr","email":"893634104@qq.com","commits":1}]},"readingTime":{"minutes":20.52,"words":6155},"filePathRelative":"前端/Browser/浏览器事件循环机制/README.md","localizedDate":"2024年7月7日","excerpt":"\\n<h3>一、浏览器的进程模型</h3>\\n<h4>1. 何为进程</h4>\\n<p><strong>程序运行需要有它自己专属的内存空间，可以把这块内存空间简单的理解为进程。</strong></p>\\n<p></p>\\n<p><strong>每个应用至少有一个进程，进程之间相互独立，即使要通信，也需要双方同意。</strong></p>\\n<p>以上图例中的三个程序：QQ、微信、王者荣耀，他们内存都是相互独立的。有的多有的少，但是这无所谓。</p>\\n<p>主要能看到的是它们的内存相互之间是没有交叉的。因为如果交叉了，就会变成共享共用了，这会出现大问题的。</p>\\n<p>因为进程之所以这样设计，它的目的就是为了隔离。</p>"}');export{C as comp,m as data};
