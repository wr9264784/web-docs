import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,o as t,b as e}from"./app-yQAcOzkj.js";const a={},n=e(`<h1 id="绝对路径和相对路径" tabindex="-1"><a class="header-anchor" href="#绝对路径和相对路径"><span>绝对路径和相对路径</span></a></h1><p>当我们要去谈论一个路径，首先要清楚我们是在一个什么样的环境里边去谈论。比方说：在 <strong>操作系统</strong> 里边的路径 跟 <strong>网络环境</strong> 里边的路径，它的含义是不一样的。</p><p>而对于前端开发来说，绝大部分时候打交道的路径都是 <strong>网络</strong> 当中的 路径。</p><p>例如：</p><ul><li>img 标签的 src 属性。</li><li>a 标签。</li><li>link 标签。</li><li>ajax 里边的请求地址。</li><li>....等等。</li></ul><p>写这个路径的目的是为了完成请求。而我们或多或少都了解过 http，我们知道要发送一个请求，必须要得到一个完整的 url 地址。既然它发送请求需要完整的 url 地址，那么我们写 <strong>绝对路径</strong> 和 <strong>相对路径</strong> 是为了干嘛呢？直接写一个完整的 url 地址不就完了吗？</p><p>这是因为完整的 url 地址写起来不方便，而且维护起来也比较困难。所以，出现了一些简写的办法，但是这些简写的办法 <strong>最终它要发送请求必须还是要转换成完整的 url 地址</strong>。</p><p>举个例子，比方说我在某个 <code>html</code> 文件中编写一个 a 元素，里边随便写一个相对路径，<strong>相对路径是以 <code>./</code> 开头 或 <code>../</code> 开头的</strong>。</p><div class="language-html line-numbers-mode" data-highlighter="shiki" data-ext="html" data-title="html" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">&lt;!-- index.html --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">... 省略其他</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">a</span><span style="--shiki-light:#6F42C1;--shiki-dark:#D19A66;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./abc&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">... 省略其他</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后我们通过 js 获取 a 元素的 href 属性，并打印：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> document</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">querySelector</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&#39;a&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">href</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// http://127.0.0.1:5500/abc</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>tips：http://127.0.0.1:5500 的 ip 和 端口号是通过 vscode 的 live server 插件生成的本地服务环境，并且 <code>index.html</code> 文件需要放在根目录下，才能拼接成上面的完整路径。</p><p>可以发现，即使我们在 a 元素中写的是相对路径，但是 <strong>最终得到的是一个完整的 url 地址</strong>，不然到时候点击这个 a 元素没法请求。并且这个完整的 url 地址就是 <strong>绝对路径</strong>。</p><p>所以，<strong>绝对路径就表示一个完整的 url 地址</strong>。只不过在 绝对路径 书写的时候，它有几种简写的方法：</p><ol><li><strong>省略协议</strong>。例如上面的 <code>a</code> 元素，可以设置 <code>href</code> 属性为 <code>//127.0.0.1:5500/abc</code> ，它最终生成的 url 地址仍然是 http://127.0.0.1:5500/abc。它会自动地把你的协议添加到这个绝对路径前面。它是怎么加的呢？它就是使用当前页面的协议。这种做法还是非常有用的，比方说你在开发环境中，你的协议全部都是用的 http，但是到了生产环境，你的协议变成了 https。如果说你在 a 元素中就填写了一个完整的 url 地址，把协议加上的话，这个代码就会变得很难维护了。开发环境的协议和生产环境的协议不同从而造成很多问题。所以说，最好的做法就是直接把协议省略点，省掉之后，开发环境没有问题，只要页面的协议是 http，其他的协议都是一样的。而到了生产环境，由于页面的协议是 https，那么这个页面里边的所有其他资源也自动变为了 https。这是很多站点都非常常见的做法。</li><li><strong>省略协议、域名、端口</strong>。<code>a</code> 元素的 <code>href</code> 属性还可以写成 <code>/abc</code>，注意：<code>/abc</code> 是一个绝对路径，它是省略了协议、域名、端口后的绝对路径。按照我们之前的说法，不管你怎么写，最终都会生成一个完整的 url 地址。这个时候我们可以想象得到，这个协议、域名、端口号从哪来呢？还是来源于当前的页面。所以，<strong>如果你请求的是一个站内的地址，协议、域名、端口号跟当前页面完全一样，那么这三个部分都可以省略</strong>。</li></ol><p>其实我们所说 <strong>相对路径</strong> 和 <strong>绝对路径</strong>。</p><p>什么叫做绝对？<strong>这个绝对的含义指的是：你这个路径和当前页面的 path 没有关系</strong>。</p><p>比方说当前页面的地址是：<code>http//a.com/a</code>，在这个页面里边，我们写了这么一个路径 <code>/k</code>，那么这个路径生成的 url 地址是 <code>http://a.com/k</code>，可以发现这个生成的 <code>url</code> 地址和页面的 <code>path</code> 没有关系，也就是和 <code>/a</code> 没有关系。</p><p>所以，不轮页面上的 path 怎么变化，都不会影响到这个绝对路径生成出来的 url 地址。</p><p>在了解了绝对路径之后，我们都可以想象得到相对路径是什么。相对路径的写法是以 <strong>相对路径是以 <code>./</code> 开头 或 <code>../</code> 开头的</strong>。它相对的是什么呢？它相对的是当前页面的 <code>path</code>。这个 <code>path</code> 可不是什么文件、文件夹的路径 <code>path</code>。</p><p>比方说这里有一个页面的地址是：http://a.com/a/b/c/s/a，在这个页面中，我们写了一个相对路径 <code>./K</code>，这个 <code>./k</code> 的路径最终还是一样要生成一个完整的 url 地址。那么它是怎么生成呢？协议、域名、端口直接拿过来，然后接下来读 <code>./</code>，<code>./</code> 表示当前页面路径中最后一个斜杠，也就是页面地址中的 http://a.com/a/b/c/s/。然后再把这个地址添加到 <code>k</code> 的前面。所以，完整的 url 地址是：http://a.com/a/b/c/s/k。</p><p>如果写的相对路径是 <code>../k</code> 也是一样，<code>../</code>，表示当前页面路径的倒数第二个斜杠，也就是页面地址中的 http://a.com/a/b/c/。然后再把这个地址添加到 <code>k</code> 的前面。所以，完整的 url 地址是：http://a.com/a/b/c/k。</p><p>这就导致了相对路径生成的 url 地址是跟当前页面的 path 部分有关联的，也就意味着如果当前的页面 path 部分变了，那么即使是同样的相对路径，最终也会生成和之前不同的 url 地址。</p><p>那么，在开发中我们应该写 绝对路径 还是 相对路径 呢？这就要你的使用场景了。只要你的页面资源和其他资源它们的 path 部分相对位置是稳定的，这个时候可以使用 <strong>相对路径</strong>。反之使用 <strong>绝对路径</strong>。</p><p>举个例子：</p><p>比方说，我们有一个页面，页面的地址是 http://a.com/a/page，我们要访问某个 js 文件，js 文件的地址是 http://a.com/a/js/index.js。那么在页面中去书写这个 script 元素的时候，为了便于后续的维护，我们不会去书写完整的 url 地址，而是会简写。</p><p>如果说它有这个一个逻辑存在，就是这个页面的 path 部分 和 js 的 path 部分，它们的关系是相对稳定的，什么叫稳定呢？就是假设一开始页面是通过这样的路径访问：<code>/a/page</code>，js 是通过这样的路径访问 <code>/a/js/index.js</code>，后来变成了通过 <code>/a/b/page</code> 访问页面，js 通过 <code>/a/b/js/index.js</code> 访问。这样，它们的相对位置是稳定的，那么这个时候就适合用 <strong>相对路径</strong>。这种相对路径就可以保证页面的路径无论如何变化，都能正确找到对应 url 地址。</p><p>那么什么时候用 绝对路径 呢？那就是刚好相反。就是页面的 path 部分，跟我们的其他资源的 path 部分它们的相对位置是不稳定的。</p><p>举个例子：</p><p>像我们的单页面应用，只有一个页面，它就意味着我们使用各种路径访问的都是同一个页面，比方说：<code>http://a.com/</code>、<code>http://a.com/a/b</code>、<code>http://a.com/a/b/c</code>，而我们的某个资源，比如说这里的 js 文件，它的路径是这样的：<code>http://a.com/js/index.js</code>，那么这里的页面的 path 和 js 文件 path 相对稳定吗？那太不稳定了。</p><p>如果这个时候 script 元素的 src 属性用的是 <strong>相对路径</strong>：<code>./js/index.js</code>，当我们用 <code>http://a.com/</code> 去访问页面的时候，它生成出来的 url 地址是 <code>http://a.com/js/index.js</code>。而当我们使用 <code>http://a.com/a/b</code> 去访问页面的时候，它生成出来的 url 地址是 <code>http://a.com/a/js/index.js</code>。</p><p>而我们希望 js 的地址是固定为 <code>http://a.com/js/index.js</code>，所以这时候就应该使用 <strong>绝对路径</strong>。</p>`,32),o=[n];function l(p,d){return t(),i("div",null,o)}const c=s(a,[["render",l],["__file","index.html.vue"]]),k=JSON.parse('{"path":"/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97/JavaScript/%E5%8E%9F%E7%90%86%E5%92%8C%E5%9F%BA%E7%A1%80/%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%92%8C%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84/","title":"绝对路径和相对路径","lang":"zh-CN","frontmatter":{},"headers":[],"git":{"createdTime":1724532946000,"updatedTime":1724532946000,"contributors":[{"name":"wr","email":"893634104@qq.com","commits":1}]},"readingTime":{"minutes":7,"words":2100},"filePathRelative":"前端/前端三件套/JavaScript/原理和基础/绝对路径和相对路径/README.md","localizedDate":"2024年8月25日","excerpt":"\\n<p>当我们要去谈论一个路径，首先要清楚我们是在一个什么样的环境里边去谈论。比方说：在 <strong>操作系统</strong> 里边的路径 跟 <strong>网络环境</strong> 里边的路径，它的含义是不一样的。</p>\\n<p>而对于前端开发来说，绝大部分时候打交道的路径都是 <strong>网络</strong> 当中的 路径。</p>\\n<p>例如：</p>\\n<ul>\\n<li>img 标签的 src 属性。</li>\\n<li>a 标签。</li>\\n<li>link 标签。</li>\\n<li>ajax 里边的请求地址。</li>\\n<li>....等等。</li>\\n</ul>\\n<p>写这个路径的目的是为了完成请求。而我们或多或少都了解过 http，我们知道要发送一个请求，必须要得到一个完整的 url 地址。既然它发送请求需要完整的 url 地址，那么我们写 <strong>绝对路径</strong> 和 <strong>相对路径</strong> 是为了干嘛呢？直接写一个完整的 url 地址不就完了吗？</p>"}');export{c as comp,k as data};
